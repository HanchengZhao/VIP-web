{
  "_args": [
    [
      {
        "raw": "csvtojson",
        "scope": null,
        "escapedName": "csvtojson",
        "name": "csvtojson",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/Users/park/work/my-app/firebase/functions"
    ]
  ],
  "_from": "csvtojson@latest",
  "_id": "csvtojson@1.1.6",
  "_inCache": true,
  "_location": "/csvtojson",
  "_nodeVersion": "4.4.3",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/csvtojson-1.1.6.tgz_1495801951389_0.1832716551143676"
  },
  "_npmUser": {
    "name": "keyang",
    "email": "keyang.xiang@gmail.com"
  },
  "_npmVersion": "2.15.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "csvtojson",
    "scope": null,
    "escapedName": "csvtojson",
    "name": "csvtojson",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/csvtojson/-/csvtojson-1.1.6.tgz",
  "_shasum": "b67accbff21a47312ce5d9253f5e50b0fc09eb18",
  "_shrinkwrap": null,
  "_spec": "csvtojson",
  "_where": "/Users/park/work/my-app/firebase/functions",
  "author": {
    "name": "Keyang Xiang",
    "email": "keyang.xiang@gmail.com"
  },
  "bin": {
    "csvtojson": "./bin/csvtojson"
  },
  "bugs": {
    "url": "https://github.com/Keyang/node-csvtojson/issues"
  },
  "contributors": [
    {
      "name": "Daniel Cohen",
      "email": "dcohenb@gmail.com",
      "url": "https://github.com/dcohenb"
    },
    {
      "name": "Trang",
      "email": "trangtungn@gmail.com",
      "url": "https://github.com/trangtungn"
    },
    {
      "name": "Matthias Lienau",
      "email": "matthias@mlienau.de",
      "url": "https://github.com/atufkas"
    },
    {
      "name": "Alec Fenichel",
      "email": "alec.fenichel@gmail.com",
      "url": "https://github.com/fenichelar"
    },
    {
      "name": "Blake Blackshear",
      "url": "https://github.com/blakeblackshear"
    },
    {
      "name": "Dimitri Kennedy",
      "email": "dimitrikennedy@gmail.com",
      "url": "https://github.com/roodboi"
    },
    {
      "url": "https://github.com/markwithers"
    },
    {
      "name": "Robert Porter",
      "url": "https://github.com/colarob"
    },
    {
      "name": "Jessica Good",
      "url": "https://github.com/jessicagood"
    },
    {
      "url": "https://github.com/jondayft"
    },
    {
      "name": "Dane Petersen",
      "url": "https://github.com/thegreatsunra"
    },
    {
      "name": "Jimi Ford",
      "url": "https://github.com/JimiHFord"
    },
    {
      "name": "Hocine Moukaideche",
      "url": "https://github.com/Off76"
    },
    {
      "name": "Keyang Xiang",
      "email": "keyang.xiang@gmail.com",
      "url": "https://github.com/Keyang"
    },
    {
      "name": "Ionică Bizău",
      "email": "contact@ionicabizau.net",
      "url": "https://github.com/IonicaBizau"
    },
    {
      "name": "Sean Lang",
      "email": "slang800@gmail.com",
      "url": "https://github.com/slang800"
    },
    {
      "name": "Tom Dodson",
      "email": "t3.dodson@gmail.com",
      "url": "https://github.com/t3dodson"
    },
    {
      "name": "Jeff Johnson",
      "url": "https://github.com/jeffcjohnson"
    },
    {
      "name": "Amila Welihinda",
      "email": "amilajack@gmail.com",
      "url": "https://github.com/amilajack"
    },
    {
      "name": "Zsolt R. Molnar",
      "url": "https://github.com/molnarzs"
    }
  ],
  "dependencies": {
    "lodash": "^4.17.3",
    "strip-bom": "1.0.0"
  },
  "description": "A tool concentrating on converting csv data to JSON with customised parser supporting",
  "devDependencies": {
    "grunt": "^0.4.5",
    "grunt-browserify": "^4.0.1",
    "grunt-contrib-jshint": "^0.11.2",
    "grunt-contrib-uglify": "^0.11.0",
    "grunt-contrib-watch": "^0.6.1",
    "grunt-git": "^0.3.5",
    "grunt-madge": "0.0.6",
    "grunt-mocha-test": "^0.12.7",
    "grunt-newer": "^1.1.0",
    "imgur": "^0.1.5",
    "load-grunt-tasks": "^3.4.0",
    "minimist": "^1.2.0",
    "mocha": "^2.4.5"
  },
  "directories": {},
  "dist": {
    "shasum": "b67accbff21a47312ce5d9253f5e50b0fc09eb18",
    "tarball": "https://registry.npmjs.org/csvtojson/-/csvtojson-1.1.6.tgz"
  },
  "engines": {
    "node": ">=0.10"
  },
  "gitHead": "bd563764bd5bbb7a50503ca78b5fd0a6452d1412",
  "homepage": "https://github.com/Keyang/node-csvtojson",
  "keywords": [
    "csv",
    "csv parser",
    "parse csv",
    "csvtojson",
    "json",
    "csv to json",
    "csv convert",
    "tojson",
    "convert csv to json",
    "csv-json"
  ],
  "license": "MIT",
  "maintainers": [
    {
      "name": "keyang",
      "email": "keyang.xiang@gmail.com"
    }
  ],
  "name": "csvtojson",
  "optionalDependencies": {},
  "readme": "[![Build Status](https://travis-ci.org/Keyang/node-csvtojson.svg?branch=master)](https://travis-ci.org/Keyang/node-csvtojson)\n\n\n#CSVTOJSON\n\nNodejs csv to json converter. Fully featured:\n\n* Pipe in / Pipe out\n* Use as Command Line tool or a Node.js lib\n* Parse CSV to JSON or CSV column arrays\n* Support all types of CSV\n* Non-blocking parsing / multi core support\n* [Extremely fast](https://github.com/Keyang/node-csvtojson/blob/develop/docs/performance.md): **4 - 6 times faster** than other csv parsers on node.js\n* Streaming data / low memory usage on large CSV data source\n\n\nThanks all the [contributors](https://github.com/Keyang/node-csvtojson/graphs/contributors)\n\n\n## Major update v1.1.0\n\nVersion 1.1.0 has added new features and optimised lib performance. It also introduced simpler APIs to use. Thus readme is re-written to adapt the preferred new APIs. The lib will support old APIs. To review the old readme please [click here](https://github.com/Keyang/node-csvtojson/blob/develop/readme-old.md).\n\n* [Performance Optimisation](https://github.com/Keyang/node-csvtojson/blob/develop/docs/performance.md#performance-optimisation): V1.1.0 is 30%-50% faster\n* Better error tolerance\n* Simplified API (see below)\n\nAll changes are backward compatible.\n\n# Demo\n\n[Here](http://keyangxiang.com/csvtojson/) is a free online csv to json service ultilising latest csvtojson module.\n\n\n# Menu\n\n* [Quick Start](#quick-start)\n* [API](#api)\n* [Contribution](#contribution)\n* [Change Logs](#change-log)\n\n# Quick Start\n\n* [As Library](#library)\n* [As Command Line Tool](#command-line-usage)\n\n## Library\n\n### Installation\n\n```\nnpm i --save csvtojson\n```\n\n### From CSV String\n\n```js\n/**\ncsvStr:\n1,2,3\n4,5,6\n7,8,9\n*/\nconst csv=require('csvtojson')\ncsv({noheader:true})\n.fromString(csvStr)\n.on('csv',(csvRow)=>{ // this func will be called 3 times\n\tconsole.log(csvRow) // => [1,2,3] , [4,5,6]  , [7,8,9]\n})\n.on('done',()=>{\n\t//parsing finished\n})\n```\n\n### From CSV File\n\n```js\n/** csv file\na,b,c\n1,2,3\n4,5,6\n*/\nconst csvFilePath='<path to csv file>'\nconst csv=require('csvtojson')\ncsv()\n.fromFile(csvFilePath)\n.on('json',(jsonObj)=>{\n\t// combine csv header row and csv line to a json object\n\t// jsonObj.a ==> 1 or 4\n})\n.on('done',(error)=>{\n\tconsole.log('end')\n})\n\n```\n\nNote that `.fromFile(filePath[ ,cb ,options])` takes an `options` parameter which will be passed to `fs.createReadStream()`. See [here](https://nodejs.org/dist/latest-v6.x/docs/api/fs.html#fs_fs_createreadstream_path_options) for docs.\n\n### From CSV Stream\n\n```js\n//const csvReadStream -- Readable stream for csv source\nconst csv=require('csvtojson')\n\ncsv()\n.fromStream(csvReadStream)\n.on('csv',(csvRow)=>{\n\t// csvRow is an array\n})\n.on('done',(error)=>{\n\n})\n\n```\n\n### From CSV Url\n\n```js\nconst request=require('request')\nconst csv=require('csvtojson')\n\ncsv()\n.fromStream(request.get('http://mywebsite.com/mycsvfile.csv'))\n.on('csv',(csvRow)=>{\n\t// csvRow is an array\n})\n.on('done',(error)=>{\n\n})\n\n```\n\n### Convert to CSV row arrays with csv header row\n\n```js\n/**\ncsvStr:\na,b,c\n1,2,3\n4,5,6\n*/\n\nconst csv=require('csvtojson')\ncsv()\n.fromString(csvStr)\n.on('csv',(csvRow)=>{ //this func will be called twice. Header row will not be populated\n\t// csvRow =>  [1,2,3] and [4,5,6]\n})\n.on('done',()=>{\n\tconsole.log('end')\n})\n```\n\n### Convert to JSON without csv header row\n\n```js\n/**\ncsvStr:\n1,2,3\n4,5,6\n7,8,9\n*/\n\nconst csv=require('csvtojson')\ncsv({noheader:true})\n.fromString(csvStr)\n.on('json',(json)=>{ //this func will be called 3 times\n\t// json.field1 => 1,4,7\n\t// json.field2 => 2,5,8\n\t// json.field3 => 3,6,9\n})\n.on('done',()=>{\n\tconsole.log('end')\n})\n```\n\n## Command Line Usage\n\n### Installation\n\n```\n$ npm i -g csvtojson\n```\n\n### Usage\n\n\n```\n$ csvtojson [options] <csv file path>\n```\n\n### Example\n\nConvert csv file and save result to json file:\n\n```\n$ csvtojson source.csv > converted.json\n```\n\nUse multiple cpu-cores:\n\n```\n$ csvtojson --workerNum=4 source.csv > converted.json\n```\n\nPipe in csv data:\n\n```\n$ cat ./source.csv | csvtojson > converted.json\n```\n\nPrint Help:\n\n```\n$ csvtojson\n```\n\n# API\n\n```js\nconst csv=require('csvtojson')\nconst converter=csv(params) //params see below Parameters section\n\n```\n\nIn above, `converter` is an instance of Converter which is a subclass of node.js `Transform` class.\n\n* [Parameters](#parameters)\n* [Events](#events)\n* [Hook / Transform](#hook-&-transform)\n* [Nested JSON Structure](#nested-json-structure)\n* [Header Row](#header-row)\n* [Multi CPU Core Support](#multi-cpu-core-support)\n\n\n## Parameters\n\n`require('csvtojson')` returns a constructor function which takes 2 arguments:\n\n1. parser parameters\n2. Stream options\n\n```js\nconst csv=require('csvtojson')\nconst converter=csv(parserParameters, streamOptions)\n```\nBoth arguments are optional.\n\nFor `Stream Options` please read [Stream Option](https://nodejs.org/api/stream.html#stream_new_stream_transform_options) from Node.JS\n\n`parserParameters` is a JSON object like:\n\n```js\nconst converter=csv({\n\tnoheader:true,\n\ttrim:true,\n})\n```\nFollowing parameters are supported:\n\n* **delimiter**: delimiter used for seperating columns. Use \"auto\" if delimiter is unknown in advance, in this case, delimiter will be auto-detected (by best attempt). Use an array to give a list of potential delimiters e.g. [\",\",\"|\",\"$\"]. default: \",\"\n* **quote**: If a column contains delimiter, it is able to use quote character to surround the column content. e.g. \"hello, world\" wont be split into two columns while parsing. Set to \"off\" will ignore all quotes. default: \" (double quote)\n* **trim**: Indicate if parser trim off spaces surrounding column content. e.g. \"  content  \" will be trimmed to \"content\". Default: true\n* **checkType**: This parameter turns on and off whether check field type. Default is false.\n* **toArrayString**: Stringify the stream output to JSON array. This is useful when pipe output to a file which expects stringified JSON array. default is false and only stringified JSON (without []) will be pushed to downstream.\n* **ignoreEmpty**: Ignore the empty value in CSV columns. If a column value is not given, set this to true to skip them. Default: false.\n* **workerNum**: Number of worker processes. The worker process will use multi-cores to help process CSV data. Set to number of Core to improve the performance of processing large csv file. Keep 1 for small csv files. Default 1.\n* **noheader**:Indicating csv data has no header row and first row is data row. Default is false. See [header row](#header-row)\n* **headers**: An array to specify the headers of CSV data. If --noheader is false, this value will override CSV header row. Default: null. Example: [\"my field\",\"name\"]. See [header row](#header-row)\n* **flatKeys**: Don't interpret dots (.) and square brackets in header fields as nested object or array identifiers at all (treat them like regular characters for JSON field identifiers). Default: false.\n* **maxRowLength**: the max character a csv row could have. 0 means infinite. If max number exceeded, parser will emit \"error\" of \"row_exceed\". if a possibly corrupted csv data provided, give it a number like 65535 so the parser wont consume memory. default: 0\n* **checkColumn**: whether check column number of a row is the same as headers. If column number mismatched headers number, an error of \"mismatched_column\" will be emitted.. default: false\n* **eol**: End of line character. If omitted, parser will attempt to retrieve it from the first chunks of CSV data.\n* **escape**: escape character used in quoted column. Default is double quote (\") according to RFC4108. Change to back slash (\\\\) or other chars for your own case.\n* **includeColumns**: This parameter instructs the parser to include only those columns as specified by an array of column indexes or header names.  Example: [0,2,3,\"name\"] will parse and include only columns 0, 2, 3, and column with header \"name\" in the JSON output.\n* **ignoreColumns**: This parameter instructs the parser to ignore columns as specified by an array of column indexes or header names.  Example: [1,3,5,\"title\",\"age\"] will ignore columns 1, 3, 5, title column and age column and will not return them in the JSON output.\n\nAll parameters can be used in Command Line tool.\n\n\n## Events\n\n`Converter` class defined a series of events.\n\n### json\n\n`json` event is emitted for each parsed CSV line. It passes JSON object and the row number of the CSV line in its callback function.\n\n```js\nconst csv=require('csvtojson')\ncsv()\n.on('json',(jsonObj, rowIndex)=>{\n\t//jsonObj=> {header1:cell1,header2:cell2}\n\t//rowIndex=> number\n})\n```\n\n### csv\n\n`csv` event is emitted for each CSV line. It passes an array object which contains cells content of one csv row.\n\n```js\nconst csv=require('csvtojson')\ncsv()\n.on('csv',(csvRow, rowIndex)=>{\n\t//csvRow=> [cell1, cell2, cell3]\n\t//rowIndex=> number\n})\n```\n\n`csvRow` is always an array of strings without types.\n\n`csv` event is the fastest parse event while `json` and `data` event is about 2 times slower. Thus if `csv` is enough, for best performance, just use it without `json` and `data` event.\n\n### data\n\n`data` event is emitted for each parsed CSV line. It passes buffer of strigified JSON unless `objectMode` is set true in stream option.\n\n```js\nconst csv=require('csvtojson')\ncsv()\n.on('data',(data)=>{\n\t//data is a buffer object\n\tconst jsonStr= data.toString('utf8')\n})\n```\n\n### error\n`error` event is emitted if there is any errors happened during parsing.\n\n```js\nconst csv=require('csvtojson')\ncsv()\n.on('error',(err)=>{\n\tconsole.log(err)\n})\n```\n\nNote that if `error` being emitted, the process will stop as node.js will automatically `unpipe()` upper-stream and chained down-stream<sup>1</sup>. This will cause `end` / `end_parsed` event never being emitted because `end` event is only emitted when all data being consumed <sup>2</sup>.\n\n1. [Node.JS Readable Stream](https://github.com/nodejs/node/blob/master/lib/_stream_readable.js#L572-L583)\n2. [Writable end Event](https://nodejs.org/api/stream.html#stream_event_end)\n\n### record_parsed\n\n`record_parsed` event is emitted for each parsed CSV line. It is combination of `json` and `csv` events. For better performance, try to use `json` and `csv` instead.\n\n```js\nconst csv=require('csvtojson')\ncsv()\n.on('record_parsed',(jsonObj, row, index)=>{\n})\n```\n### end\n\n`end` event is emitted when all CSV lines being parsed.\n\n### end_parsed\n\n`end_parsed` event is emitted when all CSV lines being parsed. The only difference between `end_parsed` and `end` events is `end_parsed` will pass in a JSON array which contains all JSON objects. For better performance, try to use `end` event instead.\n\n```js\nconst csv=require('csvtojson')\ncsv()\n.on('end_parsed',(jsonArrObj)=>{\n})\n```\n\n### done\n\n`done` event is emitted either after `end` or `error`. This indicates the processor has stopped.\n\n```js\nconst csv=require('csvtojson')\ncsv()\n.on('done',(error)=>{\n\t//do some stuff\n})\n```\n\nif any error during parsing, it will be passed in callback.\n\n## Hook & Transform\n\n### Raw CSV Data Hook\n\n```js\nconst csv=require('csvtojson')\ncsv()\n.preRawData((csvRawData,cb)=>{\n\tvar newData=csvRawData.replace('some value','another value')\n\tcb(newData);\n})\n.on('json',(jsonObj)=>{\n\n});\n```\n\nthe function in `preRawData` will be called directly with the string from upper stream.\n\n### CSV File Line Hook\n\n```js\nconst csv=require('csvtojson')\ncsv()\n.preFileLine((fileLineString, lineIdx)=>{\n\tif (lineIdx === 2){\n\t\treturn fileLineString.replace('some value','another value')\n\t}\n\treturn fileLineString\n})\n.on('json',(jsonObj)=>{\n\n});\n```\n\nthe function is called each time a file line being found in csv stream. the `lineIdx` is the file line number in the file. The function should return a string to processor.\n\n\n### Result transform\n\n```js\nconst csv=require('csvtojson')\ncsv()\n.transf((jsonObj,csvRow,index)=>{\n\tjsonObj.myNewKey='some value'\n})\n.on('json',(jsonObj)=>{\n\tconsole.log(jsonObj.myNewKey) // some value\n});\n```\n\n`Transform` happens after CSV being parsed before result being emitted or pushed to downstream. This means if `jsonObj` is changed, the corresponding field in `csvRow` will not change. Vice versa. The events will emit changed value and downstream will receive changed value.\n\n`Transform` will cause some performance panelties because it voids optimisation mechanism. Try to use Node.js `Transform` class as downstream for transformation instead.\n\n\n\n\n## Nested JSON Structure\n\nOne of the powerful feature of `csvtojson` is the ability to convert csv line to a nested JSON by correctly defining its csv header row. This is default out-of-box feature.\n\nHere is an example. Original CSV:\n\n```csv\nfieldA.title, fieldA.children.0.name, fieldA.children.0.id,fieldA.children.1.name, fieldA.children.1.employee.0.name,fieldA.children.1.employee.1.name, fieldA.address.0,fieldA.address.1, description\nFood Factory, Oscar, 0023, Tikka, Tim, Joe, 3 Lame Road, Grantstown, A fresh new food factory\nKindom Garden, Ceil, 54, Pillow, Amst, Tom, 24 Shaker Street, HelloTown, Awesome castle\n\n```\nThe data above contains nested JSON including nested array of JSON objects and plain texts.\n\nUsing csvtojson to convert, the result would be like:\n\n```json\n[{\n    \"fieldA\": {\n        \"title\": \"Food Factory\",\n        \"children\": [{\n            \"name\": \"Oscar\",\n            \"id\": \"0023\"\n        }, {\n            \"name\": \"Tikka\",\n            \"employee\": [{\n                \"name\": \"Tim\"\n            }, {\n                \"name\": \"Joe\"\n            }]\n        }],\n        \"address\": [\"3 Lame Road\", \"Grantstown\"]\n    },\n    \"description\": \"A fresh new food factory\"\n}, {\n    \"fieldA\": {\n        \"title\": \"Kindom Garden\",\n        \"children\": [{\n            \"name\": \"Ceil\",\n            \"id\": \"54\"\n        }, {\n            \"name\": \"Pillow\",\n            \"employee\": [{\n                \"name\": \"Amst\"\n            }, {\n                \"name\": \"Tom\"\n            }]\n        }],\n        \"address\": [\"24 Shaker Street\", \"HelloTown\"]\n    },\n    \"description\": \"Awesome castle\"\n}]\n```\n\n### No nested JSON\n\nIn case to not produce nested JSON, simply set `flatKeys:true` in parameters.\n\n```js\n/**\ncsvStr:\na.b,a.c\n1,2\n*/\ncsv({flatKeys:true})\n.fromString(csvStr)\n.on('json',(jsonObj)=>{\n\t//{\"a.b\":1,\"a.c\":2}  rather than  {\"a\":{\"b\":1,\"c\":2}}\n});\n\n```\n\n## Header Row\n\n`csvtojson` uses csv header row as generator of JSON keys. However, it does not require the csv source containing a header row. There are 4 ways to define header rows:\n\n1. First row of csv source. Use first row of csv source as header row. This is default.\n2. If first row of csv source is header row but it is incorrect and need to be replaced. Use `headers:[]` and `noheader:false` parameters.\n3. If original csv source has no header row but the header definition can be defined. Use `headers:[]` and `noheader:true` parameters.\n4. If original csv source has no header row and the header definition is unknow. Use `noheader:true`. This will automatically add `fieldN` header to csv cells\n\n\n### Example\n\n```js\n// replace header row (first row) from original source with 'header1, header2'\ncsv({\n\tnoheader: false,\n\theaders: ['header1','header2']\n})\n\n// original source has no header row. add 'field1' 'field2' ... 'fieldN' as csv header\ncsv({\n\tnoheader: true\n})\n\n// original source has no header row. use 'header1' 'header2' as its header row\ncsv({\n\tnoheader: true\n\theaders: ['header1','header2']\n})\n\n```\n\n## Multi CPU Core Support\n\n`csvtojson` has built-in workers to allow CSV parsing happening on another process and leave Main Process non-blocked. This is very useful when dealing with large csv data on a webserver so that parsing CSV will not block the entire server due to node.js being single threaded.\n\nIt is also useful when dealing with tons of CSV data on command line. Multi-CPU core support will dramatically reduce the time needed.\n\n\nTo enable multi-cpu core, simply do:\n\n```js\ncsv({\n\tworkerNum:4  // workerNum>=1\n})\n```\n\nor in command line:\n\n```\n$ csvtojson --workerNum=4\n```\n\nThis will create 3 extra workers. Main process will only be used for delegating data / emitting result / pushing to downstream. Just keep in mind, those operations on Main process are not free and it will still take a certain amount CPU time.\n\nSee [here](https://github.com/Keyang/node-csvtojson/blob/develop/docs/performance.md#cpu-usage-leverage) for how `csvtojson` leverages CPU usage when using multi-cores.\n\n### Limitations\n\nThere are some limitations when using multi-core feature:\n\n* Does not support if a column contains line break.\n\n\n#Contribution \n\n`csvtojson` follows github convention for contributions. Here are some steps:\n\n1. Fork the repo to your github account\n2. Checkout code from your github repo to your local machine.\n3. Make code changes and dont forget add related tests.\n4. Run `npm test` locally before pushing code back.\n5. Create a [Pull Request](https://help.github.com/articles/creating-a-pull-request/) on github.\n6. Code review and merge\n7. Changes will be published to NPM within next version.\n\n#Change Log\n\n## 1.1.5\n\n* `ignoreColumns` and `includeColumns` now allow put in header names and indecies.\n* only include `child_process` when multi worker is needed.\n* allow `fs.createReadStream` options being passed in through `fromFile` function\n\n## 1.1.4\n\n* [Breaking Change!!] default value of `checkType` is now false as it causes problems on some csv docs.\n* Added ignoreColumns and includeColumns features. #138\n\n## 1.1.1\n\n* Fix bugs: preProcessLine is not emitted\n* Changed array definition in nested json structure to follow [lodash set] (https://lodash.com/docs/4.17.2#set)\n* Only use first line of csv body for type inference\n* added `done` event\n* added `hooks` section\n* removed `parserMgr`\n\n## 1.1.0\n\n* Remove support of `new Converter(true)`\n* Optimised Performance\n* Added new APIs\n\n## 1.0.2\n* supported ndjson format as per #113 and #87\n* issue: #120\n\n## 1.0.0\n* Add [Stream Options](#stream-options)\n* Change version syntax to follow x.y.z\n\n## 0.5.12\n* Added support for scientific notation number support (#100)\n* Added \"off\" option to quote parameter\n\n## 0.5.4\n* Added new feature: accept special delimiter \"auto\" and array\n\n## 0.5.2\n\n* Changed type separator from # to #!\n* Fixed bugs\n\n## 0.5.0\n\n* Fixed some bugs\n* Performance improvement\n* **Implicity type for numbers now use RegExp:/^[-+]?[0-9]*\\.?[0-9]+$/. Previously 00131 is a string now will be recognised as number type**\n* **If a column has no head, now it will use current column index as column name: 'field*'. previously parser uses a fixed index starting from 1. e.g. csv data: 'aa,bb,cc' with head 'a,b'. previously it will convert to {'a':'aa','b':'bb','field1':'cc'} and now it is {'a':'aa','b':'bb','field3':'cc'}**\n\n## 0.4.7\n* ignoreEmpty now ignores empty rows as well\n* optimised performance\n* added fromFile method\n\n## 0.4.4\n* Add error handling for corrupted CSV data\n* Exposed \"eol\" param\n\n## 0.4.3\n* Added header configuration\n* Refactored worker code\n* **Number type field now returns 0 if parseFloat returns NaN with the value of the field. Previously it returns original value in string.**\n\n## 0.4.0\n* Added Multi-core CPU support to increase performance\n* Added \"fork\" option to delegate csv converting work to another process.\n* Refactoring general flow\n\n## 0.3.21\n* Refactored Command Line Tool.\n* Added ignoreEmpty parameter.\n\n## 0.3.18\n* Fixed double qoute parse as per CSV standard.\n\n## 0.3.14\n* Added field type support\n* Fixed some minor bugs\n\n## 0.3.8\n* Empowered built-in JSON parser.\n* Change: Use JSON parser as default parser.\n* Added parameter trim in constructor. default: true. trim will trim content spaces.\n\n## 0.3.5\n* Added fromString method to support direct string input\n\n## 0.3.4\n* Added more parameters to command line tool.\n\n## 0.3.2\n* Added quote in parameter to support quoted column content containing delimiters\n* Changed row index starting from 0 instead of 1 when populated from record_parsed event\n\n## 0.3\n* Removed all dependencies\n* Deprecated applyWebServer\n* Added construct parameter for Converter Class\n* Converter Class now works as a proper stream object\n",
  "readmeFilename": "readme.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Keyang/node-csvtojson.git"
  },
  "scripts": {
    "test": "mocha ./test -R spec",
    "test-all": "mocha  ./test -R spec && CSV_WORKER=3 mocha ./test -R spec ",
    "test-debug": "mocha debug ./test -R spec"
  },
  "version": "1.1.6"
}
